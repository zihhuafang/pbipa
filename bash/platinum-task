#!/bin/bash

THISDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

function helper_load_config {
    local config_sh_fn="$1"
    test ! -z ${config_sh_fn} && test -f ${config_sh_fn} && source ${config_sh_fn}
}

function which {
    unset -f which
    which "$1"
}

function generate_config_ccs {
    # Inputs:
    #   params_genome_size
    #   params_coverage
    #   params_block_size
    #   params_ovl_opt
    #   params_ovl_flank_grace
    #   params_ovl_min_idt
    #   params_ovl_min_len
    #   params_ovl_filter_opt
    # Output:
    #   config.sh

    # First, write out the workflow options.
    echo "genome_size=${params_genome_size}" > config.sh
    echo "coverage=${params_coverage}" >> config.sh
    echo "block_size=${params_block_size}" >> config.sh
    echo "seqdb_opt='${params_seqdb_opt}'" >> config.sh
    echo "seeddb_opt='${params_seeddb_opt}'" >> config.sh
    echo "ovl_opt_erc='${params_ovl_opt}'" >> config.sh
    echo "ovl_flank_grace=${params_ovl_flank_grace}" >> config.sh
    echo "ovl_min_idt=${params_ovl_min_idt}" >> config.sh
    echo "ovl_min_len=${params_ovl_min_len}" >> config.sh
    echo "ovl_filter_opt='${params_ovl_filter_opt}'" >> config.sh
}

function build_db {
    # These are explicit inputs:
    #   params_db_prefix
    #   params_config_sh_fn
    #
    # Outputs:
    #   {db_prefix}.rdb

    helper_load_config ${params_config_sh_fn}
    local params_block_size=${block_size}
    /usr/bin/time pancake seqdb --compression 0 --block-size ${block_size} ${seqdb_opt} ${params_db_prefix} ${input_reads_fn}
    /usr/bin/time pancake seeddb ${seeddb_opt} ${params_db_prefix}.seqdb ${params_db_prefix}
}

function ovl_prepare {
    # Input:
    #   input_db
    # Output:
    #   *.txt in cwd
    #   ${output_blocks} (same info in 1 file)

    num_blocks=$(awk '/^B/{count++}END{print count}' "${input_db}")
    for ((block1=0;block1<num_blocks;block1++)); do
        echo $block1 > $block1.txt
        echo ${block1}
    done > ${output_blocks}

    if [[ ! -s ${output_blocks} ]]; then
        echo "0" > ${output_blocks}
    fi
    sleep 1
    touch slept
}

function ovl_asym_run {
    helper_load_config ${params_config_sh_fn}
    local params_ovl_opt=${ovl_opt_erc}
    local params_ovlp_flank_grace=${ovl_flank_grace}

    # These are explicit inputs:
    #   params_block_id
    #   params_num_threads
    #   params_config_sh_fn
    #   params_db_prefix

    local local_db_prefix=$(dirname ${input_seqdb})/${params_db_prefix}
    local last_block=$((params_block_id + 1))
    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.ovl_run.pancake.memtime \
    pancake ovl-hifi --num-threads ${params_num_threads} --skip-sym --write-rev --write-ids ${params_ovl_opt} --log-level=INFO ${local_db_prefix} ${local_db_prefix} ${params_block_id} ${params_block_id} 0 > ovl.m4
    
    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.ovl_run.sort.memtime \
    sort -k 1,1 ovl.m4 > ovl.sorted.m4
}

function ovl_asym_merge {
    helper_load_config ${params_config_sh_fn}
    local params_ovlp_filter_opt=${ovl_filter_opt}

    # These are explicit inputs:
    #   params_num_threads
    #   params_config_sh_fn

    cat ${input_fofn}
    while read fn; do
        ls -lH ${fn}
    done < ${input_fofn}

    sleep 1
    touch slept

    # Merge sort.
    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.ovl_merge.mergesort.memtime \
    sort -k1,1 -m $(cat ${input_fofn} | xargs) > ovl.merged.m4
    echo ovl.merged.m4 > ovl.merged.fofn

    # Filter.
    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.ovl_merge.m4filt.memtime \
    falconc  m4filt-ipaRunner --n-proc ${params_num_threads} --ovls-fofn ovl.merged.fofn --output-fn ${output_ovl} ${params_ovlp_filter_opt} --filter-log m4-readfilt.log
}

function assemble {
    set -o

    helper_load_config ${params_config_sh_fn}
    local params_ovlp_min_idt=${ovl_min_idt}
    local params_ovlp_min_len=${ovl_min_len}

    # These are explicit inputs:
    #   params_ctg_prefix
    #   params_config_sh_fn

    ln -sf ${input_m4} preads.m4
    ln -sf ${input_reads} preads4falcon.fasta

    # Make ovlp_to_graph reproducible.
    export PYTHONHASHSEED=2147483647

    # Run the assembly.
    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.assemble.m4filtcontained.memtime \
    falconc m4filt-contained --min-idt ${params_ovlp_min_idt} --min-len ${params_ovlp_min_len} --in preads.m4 --out preads.filtered.m4

    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.assemble.ovlp_to_graph.memtime \
    python3 -m falcon_kit.mains.ovlp_to_graph --ctg-prefix "${params_ctg_prefix}" --overlap-file preads.filtered.m4 >| fc_ovlp_to_graph.log

    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.assemble.graph_to_contig.memtime \
    python3 ${PLATINUM_WORKSPACE}/scripts/graph_to_contig.py --seqdb-fn ${input_seqdb}

    # Implicit outputs: p_ctg.fasta, a_ctg_all.fasta, p_ctg_tiling_path, a_ctg_all_tiling_path

    if [[ -s p_ctg.fasta ]]; then
        ls -larth p_ctg.fasta
        pwd
        samtools faidx p_ctg.fasta  # for oric later
        (grep ">" p_ctg.fasta | grep "ctg_circular" | cut -d ' ' -f 1 | tr -d ">" > circular_contigs.csv) || touch circular_contigs.csv
        falconc stats-assembly --fasta p_ctg.fasta >| p_ctg.fasta.stats
    else
        ls -larth
        touch circular_contigs.csv
        touch p_ctg.fasta.stats
    fi

    # Given a_ctg_all.fasta, write a_ctg.fasta:
    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.assemble.dedup_a_tigs.memtime \
    python3 -m falcon_kit.mains.dedup_a_tigs >| a_ctg.fasta

    if [[ -s a_ctg.fasta ]]; then
        samtools faidx a_ctg.fasta
    fi

    # Given a_ctg.fasta and a_ctg_all_tiling_path, write a_ctg_tiling_path:
    /usr/bin/time --format="cmd: %C\\nreal_time: %e s\\nuser_time: %U s\\nsys_time: %S s\\nmax_rss: %M kB\\nexit_status: %x" -o log.assemble.dedup_a_tph.memtime \
    python3 -m falcon_kit.mains.dedup_a_tp >| a_ctg_tiling_path

    # Collect all info needed to format the GFA-1 and GFA-2 representations of
    # the assembly graphs.
#    time python3 -m falcon_kit.mains.collect_pread_gfa >| asm.gfa.json
#    time python3 -m falcon_kit.mains.collect_pread_gfa --add-string-graph >| sg.gfa.json
#    time python3 -m falcon_kit.mains.collect_contig_gfa >| contig.gfa.json

    # Output the assembly pread graph.
#    time python3 -m falcon_kit.mains.gen_gfa_v1 asm.gfa.json >| asm.gfa
#    time python3 -m falcon_kit.mains.gen_gfa_v2 asm.gfa.json >| asm.gfa2
#    time python3 -m falcon_kit.mains.gen_bandage_csv asm.gfa.json >| asm.csv

    # Output the string graph.
#    time python3 -m falcon_kit.mains.gen_gfa_v1 sg.gfa.json >| sg.gfa
#    time python3 -m falcon_kit.mains.gen_gfa_v2 sg.gfa.json >| sg.gfa2
#    time python3 -m falcon_kit.mains.gen_bandage_csv sg.gfa.json >| sg.csv

    # Output the contig graph with associate contigs attached to each primary contig.
#    time python3 -m falcon_kit.mains.gen_gfa_v2 contig.gfa.json >| contig.gfa2
}

function help {
    # These can be run from any workflow engine.
    # We call them from both snakemake and cromwell.

    echo "For any subcommand, pass arguments by name in the environment."
    # (The list of subcommands is on the case statement below.)
}

# First, try any non-task commands.
case $1 in
  rm_las \
  |help)
    set -eu -o pipefail
    $*
    exit 0
    ;;
esac

# For a task, print the environment.
env | sort >&2

case $1 in
  which \
  |generate_config_ccs \
  |build_db \
  |ovl_prepare \
  |ovl_asym_run \
  |ovl_asym_merge \
  |assemble \
)
    set -vexu -o pipefail
    $*
    ;;
*)
    echo "Bad sub-command for '$0 $@'"
    exit 1
    ;;
esac
